class Register:
    """
    CPU Registers

    See:
    - http://www.pastraiser.com/cpu/gameboy/gameboy_opcodes.html
    - https://realboyemulator.files.wordpress.com/2013/01/gbcpuman.pdf (pages 61-64)
    - http://gameboy.mongenel.com/dmg/lesson1.html
    - http://gbdev.gg8.se/wiki/articles/CPU_Registers_and_Flags

    8-bit registers (can be combined to read as 16-bit registers):
    |15 ... 8 | 7 ... 0 |
    |    A    |    F    |
    |    B    |    C    |
    |    D    |    E    |
    |    H    |    L    |

        A - Accumulator
            #TODO: Description

        F - Flags
            |7|6|5|4|3|2|1|0|
            |Z|N|H|C|_|_|_|_|
                Z - Zero Flag
                    This bit is set when the result of a math operation is zero or two values match when using the CP
                    instruction.
                N - Subtract Flag
                    This bit is set if a subtraction was performed in the last math instruction.
                H - Half Carry Flag
                    This bit is set if a carry occurred from the lower nibble (i.e. lower 4 bits of the result) in the
                    last math operation.
                C - Carry Flag
                    This bit is set if a carry occurred from the last math operation (i.e. when the result of an
                    addition became bigger than FFh (8bit) or FFFFh (16bit). Or when the result of a subtraction or
                    comparison became less than zero) or if register A is the smaller value when executing the CP
                    instruction.
                _ - Not used, always zero

    16-bit registers
    |15 ... 0|
    |   SP   |
    |   PC   |

        SP - Stack Pointer
            Points to the current stack position.
            The GameBoy Stack Pointer is used to keep track of the top of the "stack". The stack is used for saving
            variables, saving return addresses, passing arguments to subroutines, and various other uses that might be
            conceived by the individual programmer.
            As information is put onto the stack, the stack grows downward in RAM memory. As a result, the Stack Pointer
            should always be initialized at the highest location of RAM space that has been allocated for use by the
            stack. For instance, if a programmer wishes to locate the Stack Pointer at the top of low RAM space
            ($C000-$DFFF) he would set the Stack Pointer to $E000 using the command LD SP,$E000. (The Stack Pointer
            automatically decrements before it puts something onto the stack so it is perfectly acceptable to assign it
            a value which points to a memory address which is one location past the end of available RAM.)
            The GameBoy stack pointer is initialized to $FFFE on power up but a programmer should not rely on this
            setting and rather should explicitly set its value.
        PC - Program Counter
            Points to the next instruction to be executed in the Game Boy memory.
            On power up, the GameBoy Program Counter is initialized to $0100 and the instruction found at this location
            in ROM is executed. The Program Counter from this point on is controlled, indirectly, by the program
            instructions themselves that were generated by the programmer of the ROM cart.
    """
    def __init__(self):
        # 8-bit registers (can be combined to read as 16-bit registers)
        self.A = 0x00  # Accumulator
        self.F = 0x00  # Flags

        self.B = 0x00
        self.C = 0x00

        self.D = 0x00
        self.E = 0x00

        self.H = 0x00
        self.L = 0x00

        # 16-bit registers
        self.SP = 0xFFFE  # Stack Pointer
        self.PC = 0x0100  # Program Counter

    # Set/reset Flags
    def _set_flag(self,bit_position,new_value):
        """
        Change specified flag bit in register F.
        :param bit_position: Bit to change
        :param new_value: New value for specified bit
        """
        mask = 1 << bit_position
        if (self.F & mask) != (new_value << bit_position):  # If current value is != from new_value, flip current value
            self.F = self.F ^ mask

    def set_zero_flag(self,new_value):
        """
        Set Zero flag to given value.
        :param new_value:  New value for Zero flag.
        """
        self._set_flag(7,new_value)

    def set_subtract_flag(self,new_value):
        """
        Set Subtract flag to given value.
        :param new_value:  New value for Subtract flag.
        """
        self._set_flag(6,new_value)

    def set_half_carry_flag(self,new_value):
        """
        Set Half Carry flag to given value.
        :param new_value:  New value for Half Carry flag.
        """
        self._set_flag(5,new_value)

    def set_carry_flag(self,new_value):
        """
        Set Carry flag to given value.
        :param new_value:  New value for Carry flag.
        """
        self._set_flag(4,new_value)

    # GET methods for 16-bit register combinations
    def get_af(self):
        """
        Get AF value.
        :return: AF values as single 16-bit value
        """
        return (self.A << 8) | self.F  # A==high / F==low

    def get_bc(self):
        """
        Get BC value.
        :return: BC values as single 16-bit value
        """
        return (self.B << 8) | self.C  # B==high / C==low

    def get_de(self):
        """
        Get DE value.
        :return: DE values as single 16-bit value
        """
        return (self.D << 8) | self.E  # D==high / E==low

    def get_hl(self):
        """
        Get HL value.
        :return: HL values as single 16-bit value
        """
        return (self.H << 8) | self.L  # H==high / L==low

    # SET methods for 16-bit register combinations
    def set_af(self, d16):
        """
        Sets AF values to d16
        :param d16: Hex value to set (assumes it is in big endian format)
        """
        self.F = d16 & 0x00ff  # A==high / F==low
        self.A = (d16 >> 8) & 0x00ff

    def set_bc(self, d16):
        """
        Sets BC values to d16
        :param d16: Hex value to set (assumes it is in big endian format)
        """
        self.C = d16 & 0x00ff  # B==high / C==low
        self.B = (d16 >> 8) & 0x00ff

    def set_de(self, d16):
        """
        Sets DE values to d16
        :param d16: Hex value to set (assumes it is in big endian format)
        """
        self.E = d16 & 0x00ff  # D==high / E==low
        self.D = (d16 >> 8) & 0x00ff

    def set_hl(self, d16):
        """
        Sets HL values to d16
        :param d16: Hex value to set (assumes it is in big endian format)
        """
        self.L = d16 & 0x00ff  # H==high / L==low
        self.H = (d16 >> 8) & 0x00ff

    # ADD methods for 16-bit register combinations
    def add_af(self, d16):
        """
        Adds d16 to the current AF values.
        :param d16: Hex value to add (assumes it is in big endian format)
        """
        af_inc = self.get_af() + d16  # TODO: what if the result goes above 0xFFFF?

        self.F = af_inc & 0x00ff
        self.A = (af_inc >> 8) & 0x00ff

    def add_bc(self, d16):
        """
        Adds d16 to the current BC values.
        :param d16: Hex value to add (assumes it is in big endian format)
        """
        bc_inc = self.get_bc() + d16  # TODO: what if the result goes above 0xFFFF?

        self.C = bc_inc & 0x00ff
        self.B = (bc_inc >> 8) & 0x00ff

    def add_de(self, d16):
        """
        Adds d16 to the current DE values.
        :param d16: Hex value to add (assumes it is in big endian format)
        """
        de_inc = self.get_de() + d16  # TODO: what if the result goes above 0xFFFF?

        self.E = de_inc & 0x00ff
        self.D = (de_inc >> 8) & 0x00ff

    def add_hl(self, d16):
        """
        Adds d16 to the current HL values.
        :param d16: Hex value to add (assumes it is in big endian format)
        """
        hl_inc = self.get_hl() + d16  # TODO: what if the result goes above 0xFFFF?

        self.L = hl_inc & 0x00ff
        self.H = (hl_inc >> 8) & 0x00ff

    # SUB methods for 16-bit register combinations
    def sub_af(self, d16):
        """
        Subtracts d16 of the current AF values.
        :param d16: Hex value to subtract (assumes it is in big endian format)
        """
        af_sub = abs(self.get_af() - d16)  # TODO: what if the result goes below 0x0000?

        self.F = af_sub & 0x00ff
        self.A = (af_sub >> 8) & 0x00ff

    def sub_bc(self, d16):
        """
        Subtracts d16 of the current BC values.
        :param d16: Hex value to subtract (assumes it is in big endian format)
        """
        bc_sub = abs(self.get_bc() - d16)  # TODO: what if the result goes below 0x0000?

        self.C = bc_sub & 0x00ff
        self.B = (bc_sub >> 8) & 0x00ff

    def sub_de(self, d16):
        """
        Subtracts d16 of the current DE values.
        :param d16: Hex value to subtract (assumes it is in big endian format)
        """
        de_sub = abs(self.get_de() - d16)  # TODO: what if the result goes below 0x0000?

        self.E = de_sub & 0x00ff
        self.D = (de_sub >> 8) & 0x00ff

    def sub_hl(self, d16):
        """
        Subtracts d16 of the current HL values.
        :param d16: Hex value to subtract (assumes it is in big endian format)
        """
        hl_sub = abs(self.get_hl() - d16)  # TODO: what if the result goes below 0x0000?

        self.L = hl_sub & 0x00ff
        self.H = (hl_sub >> 8) & 0x00ff
